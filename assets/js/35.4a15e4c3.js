(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{372:function(t,a,e){"use strict";e.r(a);var c=e(33),n=Object(c.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"computed-和-watch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch"}},[t._v("#")]),t._v(" computed 和 watch")]),t._v(" "),e("p",[t._v("computed：计算属性")]),t._v(" "),e("p",[t._v("计算属性是由data中的已知值，得到的一个新值。\n这个新值只会根据已知值的变化而变化，其他不相关的数据的变化不会影响该新值。\n计算属性不在data中，计算属性新值的相关已知值在data中。\n别人变化影响我自己。")]),t._v(" "),e("p",[t._v("watch：监听数据的变化\n监听data中数据的变化\n监听的数据就是data中的已知值\n我的变化影响别人")]),t._v(" "),e("p",[t._v("功能上：computed是计算属性，也就是依赖其它的属性计算所得出最后的值。watch是去监听一个值的变化，然后执行相对应的函数\n使用上：computed中的函数必须要用return返回；watch的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作，不是必须要用return\n性能上：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调\n场景上：computed：当一个属性受多个属性影响的时候，例子：购物车商品结算；watch：当一条数据影响多条数据的时候，例子：搜索框")]),t._v(" "),e("h2",{attrs:{id:"使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[t._v("#")]),t._v(" 使用场景")]),t._v(" "),e("ol",[e("li",[t._v("watch擅长处理的场景：一个数据影响多个数据")]),t._v(" "),e("li",[t._v("computed擅长处理的场景：一个数据受多个数据影响")])])])}),[],!1,null,null,null);a.default=n.exports}}]);