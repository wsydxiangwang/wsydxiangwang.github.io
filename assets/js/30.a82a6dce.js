(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{402:function(a,e,t){a.exports=t.p+"assets/img/cache.d397f083.png"},517:function(a,e,t){"use strict";t.r(e);var v=t(33),s=Object(v.a)({},(function(){var a=this,e=a.$createElement,v=a._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"前端缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前端缓存"}},[a._v("#")]),a._v(" 前端缓存")]),a._v(" "),v("p",[a._v("缓存是性能优化中非常重要的一环，浏览器的缓存机制对开发也是非常重要的知识点。接下来以三个部分来把浏览器的缓存机制说清楚：")]),a._v(" "),v("ul",[v("li",[a._v("强缓存")]),a._v(" "),v("li",[a._v("协商缓存")]),a._v(" "),v("li",[a._v("缓存位置")])]),a._v(" "),v("h2",{attrs:{id:"强缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[a._v("#")]),a._v(" 强缓存")]),a._v(" "),v("p",[a._v("浏览器中的缓存作用分为两种情况，一种是需要发送"),v("code",[a._v("HTTP")]),a._v("请求，一种是不需要发送。")]),a._v(" "),v("p",[a._v("首先是检查强缓存，这个阶段不需要发送"),v("code",[a._v("HTTP")]),a._v("请求。")]),a._v(" "),v("h3",{attrs:{id:"expires"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[a._v("#")]),a._v(" Expires")]),a._v(" "),v("p",[a._v("Expires即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:")]),a._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[a._v("Expires"),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" Wed"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("22")]),a._v(" Nov "),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("2019")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("08")]),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("41")]),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("00")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GMT")]),a._v("\n")])])]),v("p",[a._v("表示资源在"),v("code",[a._v("2019年11月22号8点41分")]),a._v("过期，过期了就得向服务端发请求。")]),a._v(" "),v("p",[a._v("这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是"),v("strong",[a._v("服务器的时间和浏览器的时间可能并不一致")]),a._v("，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。")]),a._v(" "),v("h3",{attrs:{id:"cache-control"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[a._v("#")]),a._v(" Cache-Control")]),a._v(" "),v("p",[a._v("在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。")]),a._v(" "),v("p",[a._v("它和"),v("code",[a._v("Expires")]),a._v("本质的不同在于它并没有采用"),v("strong",[a._v("具体的过期时间点")]),a._v("这个方式，而是采用过期时长来控制缓存，对应的字段是"),v("code",[a._v("max-age")]),a._v("。比如这个例子:")]),a._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[a._v("Cache"),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("Control"),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" max"),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("age"),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("3600")]),a._v("\n")])])]),v("p",[a._v("代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。")]),a._v(" "),v("p",[a._v("Cache-Control可以在请求头或者响应头中设置，并且可以组合使用多种指令：")]),a._v(" "),v("p",[v("img",{attrs:{src:t(402),alt:""}})]),a._v(" "),v("h3",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),v("p",[a._v("其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物。")]),a._v(" "),v("p",[a._v("两者同时存在的话，"),v("strong",[a._v("Cache-Control优先级高于Expires")]),a._v("；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。")]),a._v(" "),v("p",[a._v("当然，还存在一种情况，当资源缓存时间超时了，也就是强缓存失效了，接下来怎么办？没错，这样就进入到第二级屏障——"),v("strong",[a._v("协商缓存")]),a._v("了。")]),a._v(" "),v("h2",{attrs:{id:"协商缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[a._v("#")]),a._v(" 协商缓存")]),a._v(" "),v("p",[a._v("协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：")]),a._v(" "),v("ul",[v("li",[a._v("协商缓存生效，返回304和Not Modified")]),a._v(" "),v("li",[a._v("协商缓存失效，返回200和请求结果")])]),a._v(" "),v("p",[a._v("协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。")]),a._v(" "),v("h3",{attrs:{id:"last-modified"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#last-modified"}},[a._v("#")]),a._v(" Last-Modified")]),a._v(" "),v("p",[a._v("即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。")]),a._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[a._v("Last"),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("Modified"),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" Fri"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("22")]),a._v(" Jul "),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("2016")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("01")]),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("47")]),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("00")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GMT")]),a._v("\n")])])]),v("p",[a._v("浏览器接收到后，如果再次请求，会在请求头中携带"),v("code",[a._v("If-Modified-Since")]),a._v("字段，这个字段的值也就是服务器传来的最后修改时间。")]),a._v(" "),v("p",[a._v("服务器拿到请求头中的"),v("code",[a._v("If-Modified-Since")]),a._v("的字段后，会跟服务器中该资源的最后修改时间进行对比:")]),a._v(" "),v("ul",[v("li",[a._v("如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源和200，跟常规的HTTP请求响应的流程一样。")]),a._v(" "),v("li",[a._v("否则返回304，告诉浏览器直接从缓存读取。")])]),a._v(" "),v("h3",{attrs:{id:"etag"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#etag"}},[a._v("#")]),a._v(" ETag")]),a._v(" "),v("p",[v("strong",[a._v("Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。")])]),a._v(" "),v("p",[a._v("浏览器接收到"),v("code",[a._v("ETag")]),a._v("的值，会在下次请求时，将这个值作为"),v("code",[a._v("If-None-Match")]),a._v("这个字段的内容，并放到请求头中，然后发给服务器。")]),a._v(" "),v("p",[a._v("服务器接收到"),v("code",[a._v("If-None-Match")]),a._v("后，会跟服务器上该资源的"),v("code",[a._v("ETag")]),a._v("进行比对:")]),a._v(" "),v("ul",[v("li",[a._v("如果两者不一样，说明要更新了。返回新的资源和200，跟常规的HTTP请求响应的流程一样。")]),a._v(" "),v("li",[a._v("否则返回304，告诉浏览器直接用缓存。")])]),a._v(" "),v("h3",{attrs:{id:"两者对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#两者对比"}},[a._v("#")]),a._v(" 两者对比")]),a._v(" "),v("ol",[v("li",[a._v("在精准度上，"),v("code",[a._v("ETag")]),a._v("优于"),v("code",[a._v("Last-Modified")]),a._v("。")])]),a._v(" "),v("p",[a._v("由于"),v("code",[a._v("ETag")]),a._v("是按照内容给资源上标识，因此能准确感知资源的变化。而"),v("code",[a._v("Last-Modified")]),a._v("就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:")]),a._v(" "),v("ul",[v("li",[a._v("编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。")]),a._v(" "),v("li",[v("code",[a._v("Last-Modified")]),a._v("能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的"),v("code",[a._v("Last-Modified")]),a._v("并没有体现出修改了。")])]),a._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("p",[a._v("在性能上，"),v("code",[a._v("Last-Modified")]),a._v("优于"),v("code",[a._v("ETag")]),a._v("，也很简单理解，"),v("code",[a._v("Last-Modified")]),a._v("仅仅只是记录一个时间点，而"),v("code",[a._v("Etag")]),a._v("需要根据文件的具体内容生成哈希值。")])]),a._v(" "),v("li",[v("p",[a._v("在优先级上，服务器校验优先考虑"),v("code",[a._v("Etag")])])])]),a._v(" "),v("h2",{attrs:{id:"缓存机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存机制"}},[a._v("#")]),a._v(" 缓存机制")]),a._v(" "),v("p",[a._v("强制缓存优先于协商缓存进行，若强制缓存"),v("code",[a._v("(Expires和Cache-Control)")]),a._v("生效则直接使用缓存，若不生效则进行协商缓存"),v("code",[a._v("(Last-Modified / If-Modified-Since和Etag / If-None-Match)")]),a._v("。")]),a._v(" "),v("p",[a._v("协商缓存由服务器决定是否使用缓存，")]),a._v(" "),v("p",[a._v("若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；")]),a._v(" "),v("p",[a._v("生效则返回304，继续使用缓存。")]),a._v(" "),v("h2",{attrs:{id:"缓存位置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存位置"}},[a._v("#")]),a._v(" 缓存位置")]),a._v(" "),v("p",[a._v("前面我们已经提到，当强缓存命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？")]),a._v(" "),v("p",[a._v("浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：")]),a._v(" "),v("ul",[v("li",[a._v("Service Worker")]),a._v(" "),v("li",[a._v("Memory Cache（内存缓存）")]),a._v(" "),v("li",[a._v("Disk Cache（硬盘缓存）")]),a._v(" "),v("li",[a._v("Push Cache（推送缓存）")])]),a._v(" "),v("h3",{attrs:{id:"service-worker"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#service-worker"}},[a._v("#")]),a._v(" Service Worker")]),a._v(" "),v("p",[a._v("和Web Worker类似，是独立的线程，我们可以在这个线程中缓存文件，在主线程需要的时候读取这里的文件，Service Worker使我们可以自由选择缓存哪些文件以及文件的匹配、读取规则，并且缓存是持续性的")]),a._v(" "),v("h3",{attrs:{id:"memory-cache-和-disk-cache"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#memory-cache-和-disk-cache"}},[a._v("#")]),a._v(" Memory Cache 和 Disk Cache")]),a._v(" "),v("p",[a._v("Memory Cache指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。")]),a._v(" "),v("p",[a._v("Disk Cache就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。稍微有些计算机基础的应该很好理解，就不展开了。")]),a._v(" "),v("p",[a._v("好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：")]),a._v(" "),v("ul",[v("li",[a._v("比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存")]),a._v(" "),v("li",[a._v("内存使用率比较高的时候，文件优先进入磁盘")])]),a._v(" "),v("h3",{attrs:{id:"push-cache"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#push-cache"}},[a._v("#")]),a._v(" Push Cache")]),a._v(" "),v("p",[a._v("即推送缓存，这是浏览器缓存的最后一道防线。是HTTP/2的内容，目前应用较少")]),a._v(" "),v("h2",{attrs:{id:"总结-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结-2"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),v("p",[a._v("对浏览器的缓存机制来做个简要的总结:")]),a._v(" "),v("p",[a._v("首先通过"),v("code",[a._v("Cache-Control")]),a._v("验证强缓存是否可用")]),a._v(" "),v("ul",[v("li",[a._v("如果强缓存可用，直接使用")]),a._v(" "),v("li",[a._v("否则进入协商缓存，即发送"),v("code",[a._v("HTTP")]),a._v("请求，服务器通过请求头中的"),v("code",[a._v("If-Modified-Since")]),a._v("或者"),v("code",[a._v("If-None-Match")]),a._v("这些条件请求字段检查资源是否更新\n"),v("ul",[v("li",[a._v("若资源更新，返回资源和200状态码")]),a._v(" "),v("li",[a._v("否则，返回304，告诉浏览器直接从缓存获取资源")])])])]),a._v(" "),v("br"),a._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://www.jianshu.com/p/54cc04190252?_blank",target:"_blank",rel:"noopener noreferrer"}},[a._v("深入理解浏览器的缓存机制"),v("OutboundLink")],1)]),a._v(" "),v("li",[v("a",{attrs:{href:"https://github.com/fengshi123/blog/issues/7",target:"_blank",rel:"noopener noreferrer"}},[a._v("深入理解HTTP缓存机制及原理"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=s.exports}}]);