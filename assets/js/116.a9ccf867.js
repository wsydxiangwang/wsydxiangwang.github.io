(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{514:function(o,t,e){"use strict";e.r(t);var i=e(33),s=Object(i.a)({},(function(){var o=this,t=o.$createElement,e=o._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[e("h1",{attrs:{id:"vue3-composition-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3-composition-api"}},[o._v("#")]),o._v(" Vue3 Composition API")]),o._v(" "),e("h2",{attrs:{id:"什么是-composition-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-composition-api"}},[o._v("#")]),o._v(" 什么是 Composition API")]),o._v(" "),e("p",[o._v("这种碎片化使得难以理解和维护复杂的组件。期权的分离掩盖了潜在的逻辑问题。另外，当处理单个逻辑问题时，我们必须不断地“跳动”相关代码的选项块。")]),o._v(" "),e("p",[o._v("默认vue2写法")]),o._v(" "),e("p",[o._v("易维护，可随意拆分成单独的JS文件")]),o._v(" "),e("p",[o._v("任何功能和方法都可以独立存在，可复用")]),o._v(" "),e("p",[o._v("用于解决规模问题的全新 API")]),o._v(" "),e("p",[o._v("在 Vue 3.0 中，基于对象的 2.x API 基本没有变化，并引入了 Composition API[12] — 一套全新的 API，旨在解决 Vue 在大规模应用场景中的痛点。Composition API 构建于响应式 API 之上，实现了类似于 React hook 的逻辑组成与复用，相较于 2.x 基于对象的 API 方式来说，拥有更加灵活的代码组织模式，以及更为可靠的类型推断能力。")]),o._v(" "),e("p",[o._v("Composition API 同时还提供了适用于 Vue 2.x 的版本，可通过 "),e("code",[o._v("@vue/composition-api")]),o._v("[13] 插件来在项目中使用，目前已有适用于 Vue 2 和 Vue 3 的 Composition API 实用的工具库（如 "),e("code",[o._v("vueuse")]),o._v("[14]，"),e("code",[o._v("vue-composable")]),o._v("[15]）。")])])}),[],!1,null,null,null);t.default=s.exports}}]);